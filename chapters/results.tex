
\chapter{بارسپاری کارآمد لبه شبکه برای نسل چهارم صنعت:}\label{chap:model}

\section{سیستم مدل پزدارش لبه شبکه در نسل چهارم صنعت}

\subsection{ارسال و دریافت داده برای بارسپاری}

\section{مزاحمت برنامه‌های کاربردی}
\label{subsec:interference_model}

برای محاسبه تداخل بین برنامه‌ها، ضروری است که بدانیم کدام کانتینرها روی یک سرور هم‌مکان هستند (شکل~\ref{figure:containers_combination}). همان‌طور که در این بخش بحث شد، تداخل با استفاده از روش برنامه مرکب مدل‌سازی می‌شود، به‌طوری که عوامل توصیف تداخل یک برنامه مرکب با ضرب کردن عوامل هر برنامه به‌صورت جداگانه در میزان تداخل همه برنامه‌های داخل برنامه مرکب محاسبه می‌شود. فرض کنید یک سرور بتواند حداکثر $M$ کانتینر را میزبانی کند و $A$ برنامه متمایز برای استقرار وجود داشته باشد. تعداد کانتینرها روی یک سرور می‌تواند کمتر از ظرفیت حداکثر $M$ باشد. تمام ترکیب‌های ممکن استقرار را می‌توان با استفاده از انتخاب $\binom{M+A+1}{M}$ بدست آورد. در این عبارت پیکربندی‌هایی که در آن بخشی از ظرفیت سرور پر شده یا حتی خالی است نیز در نظر گرفته شده است. به‌عنوان مثال، فرض کنید $A=4$ برنامه و ظرفیت سرور $M=6$ کانتینر باشد. با استفاده از فرمول ترکیبیاتی، تعداد ترکیب‌های ممکن کانتینرها برابر است با $\binom{11}{6}=462$، که تمام الگوهای معتبر هم‌مکانی را در بر می‌گیرد. اهمیت آماده‌سازی همه ترکیب‌های ممکن پیش از فرمول‌بندی مساله بهینه‌سازی، مربوط به متغیر تصمیم‌گیری چیدمان کانتینرهای سرورها است.

\vspace{0.5cm}
\begin{figure}[h]
\begin{minipage}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{containers_combination2.pdf}
\end{minipage}\hfill
\begin{minipage}{0.45\textwidth}
\centering
\includegraphics[width=\textwidth]{containers_combination.pdf}
\end{minipage}\hfill
\caption{چیدمان کانتینرها در سرور}
\label{figure:containers_combination}
\end{figure}
\vspace{0.5cm}

\section{فرمول‌بندی مساله بهینه‌سازی}

علائم استفاده شده در این پژوهش به طور خلاصه در جدول~\ref{table:problem_notations} آورده شده است.

\begin{table*}[h!]
\begin{center}
\caption{اندیس و مجموعه‌ها، مقادیر ثابت و متغیرهای مسئله بهینه‌سازی}
\begin{tabular}{ |c|c|r|r| }
\hline
نوع & نماد & توضیح & مقدار \\ 
\hline
\multirow{10}{*}{\rotatebox[origin=r]{90}{مجموعه‌ها}} 
& $n$ & اندیس‌ عوامل تداخل & $\{0, 1, \dots, 8\}$ \\
& $e \in \mathbb{E}$ & مجموعه دستگاه‌ها (ربات‌ها و حسگرها) & $\{1, 2, \dots, |E|\}$ \\
& $s \in \mathbb{S}$ & مجموعه سرورهای \lr{\tt{MEC}} & $\{1, 2, \dots, |S|\}$ \\
& $a \in \mathbb{A}$ & مجموعه برنامه‌های کاربردی & $\{1, 2, \dots, |A|\}$ \\
& $k \in \mathbb{K}$ & مجموعه‌ درخواست‌ها & $\{1, 2, \dots, |K|\}$ \\
& $\mathbb{K}_e$ & درخواست‌های دستگاه $e$ & مثلا $\{3, 4, \dots \}$ \\
& $\mathbb{K}_s$ & درخواست‌هایی بارسپاری شده در $s$ & مثلا $\{3, 4, \dots \}$ \\
& $a(k)$ & برنامه کاربردی درخواست $k$ & \\
& $m \in \mathbb{M}$ & ترکیب‌های بدون ترتیب ممکن در سرور & \\
& $\mathbb{A}_m$ & برنامه‌های کاربردی یک ترکیب & مثلا $(a_1,a_3, ..., |\mathbb{A}_m|)$ \\
\hline
\multirow{13}{*}{\rotatebox[origin=c]{90}{مقادیر ثابت}}
& $\mathcal{M}$ & بیشترین تعداد کانتینر بر روی سرور & $6$\\
& $\beta$ & بردار ضرایب تداخل & \\
& $P_{a(k)}$ & عوامل تداخل برای برنامه درخواست $k$ & \\
& $I_k$ & ابعاد داده ورودی برای $k$ & $10$ مگابایت \\
& $O_k$ & ابعاد داده خروجی برای $k$ & $100$ کیلوبایت \\
& $L_k$ & چرخه‌های پردازنده لازم برای $k$ & $10^8$ چرخه \\
& $\Theta_k$ & مهلت اجرای $k$ & 1 ثانیه \\
& $F_s$ & توان پردازشی $s$ & $2 \times 10^9$ چرخه در ثانیه \\
& $F_e$ & توان پردازشی محلی $e$ & $10^8$ چرخه در ثانیه \\
& $f_k$ & توان پردازشی تخصیص یافته به کانتینر $k$ & $5 \times 10^8$ چرخه در ثانیه \\
& $R_{w,e,s}$ & نرخ ارسال بی‌سیم بین $e$ و نقطه دسترسی سرور $s$ & $5 \times 10^7$ بیت بر ثانیه \\
& $R_{f,s}$ & نرخ ارسال سیمی بین نقطه دسترسی و سرور $s$ & $10^8$ بیت بر ثانیه \\
& $C_{k,\mathbb{A}_m}$ & کندی ناشی از تداخل ترکیب $m$ برای $k$ & \\
\hline
\multirow{3}{*}{\rotatebox[origin=c]{90}{متغیرها}} 
& $x_{k,e,s}$ & 1 اگر $k$ از $e$ به $s$ بارسپاری شود وگرنه 0 & \\
& $x_{k,e,0}$ & 1 اگر $k$ محلی در $e$ پردازش شود وگرنه 0 & \\
& $z_{s,m}$ & 1 اگر $s$ دارای ترکیب $m$ باشد وگرنه 0 & \\
\hline
\end{tabular}
\label{table:problem_notations}
\end{center}
\end{table*}

\subsection{فرمول پیشنهادی تداخل منابع}

همانطور که در بخش~\ref{subsec:interference_model} بحث شد، تداخل بین دو کانتینر بر اساس فرمول تداخل معرفی شده در مقاله \cite{medel2023modeling} در رابطه~\eqref{eq:mutual_interference} آمده است. بر این اساس تداخل بین دو برنامه کاربردی $a_1$ که توسط درخواست $k$ و $a_2$ که توسط درخواست $k'$ فراخوانی شده محاسبه می‌شود. ترکیب $\mathbb{A}_m=\{a_1,a_2\}$ برنامه‌های کاربردی در سرور $s$ هستند و ضرایب $\beta_n$ در عامل‌های تداخل $P_{a,n}$ توصیف کننده تداخل $C_{k,\mathbb{A}_m}$ هستند.
\begin{equation} \label{eq:mutual_interference}
    C_{k,\mathbb{A}_m} = \beta_0 + \sum_{n=1}^4 \beta_n P_{a_1,n} + \sum_{n=1}^4 \beta_{n+4} P_{a_2,n}
\end{equation}
گسترش این رابطه در این پژوهش با استفاده از ارائه مفهوم برنامه کاربردی مرکب و تاثیردهی تداخل در عوامل هرکدام از اعضای برنامه مرکب است. بر این اساس اگر بخواهیم تداخل ترکیب سه برنامه کاربردی را بررسی کنیم، رابطه~\eqref{eq:triple_interference} را معرفی می‌کنیم. در این رابطه برنامه $a_3$ توسط درخواست $k"$ فراخوانی شده است. ترکیب برنامه ها $\mathbb{A}_m=\{a_1,a_2,a_3\}$ است. برای محاسبه تداخل در برنامه مرکب، ترکیب برنامه‌های برنامه مرکب در زیرمجموعه $\mathbb{A}'_m=\{a_2,a_3\}$ معرفی شده است(برنامه $a_1$ که فرمول محاسبه تداخل برای آن نوشته می‌شود، از این زیرمجموعه حذف شده نسبت به مجموعه $\mathbb{A}_m$)
\begin{equation} \label{eq:triple_interference}
    C_{k,\mathbb{A}_m} = \beta_0 + \sum_{n=1}^4 \beta_n P_{a_1,n} + \sum_{n=1}^4 \beta_{n+4} \left(P_{a_2,n}C_{k',\mathbb{A}'_m} + P_{a_3,n}C_{k",\mathbb{A}'_m}\right)
\end{equation}
برای جمع‌بندی محاسبه تداخل برای درخواست $k$ با برنامه کاربردی $a(k)$ در رابطه\eqref{eq:total_interference} آمده است. بر این اساس در برنامه مرکب، تداخل‌های پیش‌امده توسط دیگر برنامه‌ها در عامل‌های توصیف تداخل ضرب شده است.
\begin{equation} \label{eq:total_interference}
    C_{k,\mathbb{A}_m} = \beta_0 + \sum_{n=1}^4 \beta_n P_{a(k),n} + \sum_{n=1}^4 \beta_{n+4} \left(\sum_{j \in \mathbb{K}_s} P_{a(j),n} C_{j,\mathbb{A}'_m}\right)
\end{equation}
رابطه~\eqref{eq:total_interference} که به صورت تکرار شونده به محاسبه تداخل می‌پردازد، از ابداعات این پژوهش است.

\subsection{قیود و تابع هدف مساله بهینه‌سازی}

\subsubsection{تصمیم‌گیری بارسپاری} \label{subsubsec:off_decision}

هر درخواستی که در شبکه \lr{\tt{MEC}} برای نسل چهارم صنعت طرح می‌شود بایستی توسط مدیر و هماهنگ‌کننده مرکزی شبکه تعیین تکلیف شود. به ازای هر درخواست یک تصمیم مرتبط با محل پردازش گرفته می‌شود. متغیر $x_{k,e,m}$ معرف تصمیم‌گیری برای محل  بارسپاری در سرور یا پردازش محلی برای درخواست $k$ از دستگاه $e$ است. تصمیم‌گیری برای هر درخواست ممکن است منجر به عدم امکان پاسخ‌دهی در زمان مناسب شود. بنابراین در صورتی که برای یک درخواست مشخص تصمیم به حذف گرفته شود، همه متغیرهای مربوط به آن تصمیم برابر صفر می‌شود. در صورتی که پردازش محلی قرار به انجام باشد، مقدار $x_{k,e,0}$ برابر یک و سایر $x_{k,e,s}$های دیگر مطابق قید~\eqref{eq:task_assignment} برابر صفر می‌شوند.
\begin{equation} \label{eq:task_assignment}
    \sum_{s \in \mathbb{S}} x_{k,e,s} \leq 1 \quad \forall k \in \mathbb{K}_e, e \in \mathbb{E}
\end{equation}
طبق قید‍~\eqref{eq:cont_num} تعداد کانتینرهایی که در یک سرور اجرا می‌شوند محدود به $\mathcal{M}$ است. با توجه به نیازمندی‌های حداقلی یک کانتینر و ظرفیت منابع سرور تعداد حداکثر کانتینرهای سرور مشخص می‌شود.
\begin{equation} \label{eq:cont_num}
    \sum_{k \in \mathbb{K}_e, e \in \mathbb{E}} x_{k,e,s} \leq \mathcal{M} \quad \forall s \in \mathbb{S}
\end{equation}

\subsubsection{چیدمان ماشین‌های مجازی}
چیدمان $m$ که برنامه‌های کاربردی درخواست شده در سرور $s$ دارند، توسط متغیر باینری $z_{s,m}$ نمایش داده می‌شود. هر سرور یک چیدمان غیرترتیبی از کانتینرها مطابق قید~\eqref{eq:app_layout} بایستی داشته باشد. این چیدمان با انتخاب از مجموعه برنامه‌های کاربردی بعلاوه کانتینر خالی انجام می‌گیرد.
\begin{equation} \label{eq:app_layout}
    \sum_{m \in \mathbb{M}} z_{s,m} \leq 1 \quad \forall s \in \mathbb{S}
\end{equation}
برای آنکه چیدمان انتخاب شده با بارسپاری‌های انجام گرفته در سرور هماهنگ باشند، از قید~\eqref{eq:zx_match} و قید~\eqref{eq:zx_match2} استفاده شده است.
\begin{equation} \label{eq:zx_match}
    z_{s,m} \leq x_{k,e,s} \quad \forall a(k) \in \mathbb{A}_m, k \in \mathbb{K}_e, e \in \mathbb{E}, s \in \mathbb{S}, m \in \mathbb{M}
\end{equation}
\begin{equation} \label{eq:zx_match2}
    z_{s,m} \geq \sum_{\substack{a(k) \in \mathbb{A}_m \\ k \in \mathbb{K}_e, e \in \mathbb{E}}}x_{k,e,s} - |\mathbb{A}_m| + 1 \quad \forall s \in \mathbb{S}, m \in \mathbb{M}
\end{equation}

\subsubsection{محدودیت منابع پردازشی}
هر سرور و یا دستگاهی توان پردازشی محدودی دارد. این توان پردازشی محدود بین کانتینرها تقسیم می‌شود. بر این اساس توان پردازشی درخواست‌های موجود در سرور نباید از ظرفیت پردازشی آن $F_s$ مطابق قید~\eqref{eq:server_cap} بیشتر شود. همچنین در پردازش محلی نیز نباید پردازش وظایف محلی از ظرفیت پردازش محلی دستگاه $F_e$ مطابق قید~\eqref{eq:local_cap} بیشتر شود. توان پردازشی تخصیص یافته به هر کانتینر برابر با $f^{con}_k$ و توان پردازشی تخصیص یافته به هر وظیفه محلی نیز $f^{loc}_k$ است.
\begin{equation} \label{eq:server_cap}
    \sum_{k \in \mathbb{K}_e,e \in \mathbb{E}} x_{k,e,s} f^{con}_k \leq F_s \quad \forall s \in \mathbb{S}
\end{equation}
\begin{equation} \label{eq:local_cap}
    \sum_{k \in \mathbb{K}_e} x_{k,e,0} f^{loc}_k \leq F_e \quad \forall e \in \mathbb{E}
\end{equation}

\subsubsection{مزاحمت و تاخیر پردازش} \label{subsubsec:latency}
در این پژوهش تاخیر شامل دو قسمت است، تاخیر پردازشی و تاخیر مخابره. تاخیر مخابره $D_{k,e,s}$ نیز شامل ارسال و دریافت بی‌سیم بین دستگاه و نقطه دسترسی است و همچنین ارسال و دریافت سیمی بین نقطه دسترسی تا سرور است. نرخ ارسال و دریافت در هر دو حالت بی‌سیم و سیمی مطابق رابطه~\eqref{eq:transmission_delay} بین دستگاه‌های موجود به طور مساوی تقسیم می‌شود. نرخ ارسال بی‌سیم $R_{w,e,s}$ و نرخ ارسال سیمی $R_{f,s}$ است. مدت ارسال و دریافت به ابعاد داده ورودی $I_k$ و خروجی $O_k$ درخواست وابسته است.
\begin{equation} \label{eq:transmission_delay}
    D_{k,e,s} = \left(\frac{I_k}{R_{w,e,s}} + \frac{I_k}{R_{f,s}} + \right. \\ \left. \frac{O_k}{R_{f,s}} + \frac{O_k}{R_{w,e,s}} \right) \sum_{j \in \mathbb{K}_{e'}, e' \in \mathbb{E}} x_{j,e',s}  \quad \forall k \in \mathbb{K}_e, e \in \mathbb{E}, s \in \mathbb{S}
\end{equation}
پردازش محلی مطابق رابطه~\eqref{eq:local_exec_time} تنها تاخیر پردازش را تجربه می‌کند. اگرچه توان پردازشی دستگاه‌ها، ضعیف‌تر است و موجب تاخیرهای بزرگتری می‌شود. تاخیر پردازش محلی براساس چرخه‌های $L_k$ مورد نیاز برای اجرای درخواست به‌دست می‌آید. 
\begin{equation} \label{eq:local_exec_time}
    x_{k,e,0}\frac{L_k}{f^{loc}_k} \quad \forall k \in \mathbb{K}_e, e \in \mathbb{E}
\end{equation}
اما بارسپاری شامل تاخیرهای مخابره و پردازشی می‌شود. استفاده مشترک از پهنای باند بی‌سیم و سیمی و منابع سخت‌افزاری سرور و رابطه تداخل، مطابق رابطه~\eqref{eq:off_time} موجب ایجاد عبارت‌های غیرخطی می‌شود که در بخش بعد به خطی‌سازی این عبارت‌ها می‌پردازیم.
\begin{equation} \label{eq:off_time}
    \sum_{s \in \mathbb{S}} x_{k,e,s} \left(D_{k,e,s} + \sum_{m \in \mathbb{M}} \frac{z_{s,m} L_k}{f^{con}_k} C_{k,\mathbb{A}_m}\right) \\ \forall k \in \mathbb{K}_e, e \in \mathbb{E}
\end{equation}
در نهایت قید تاخیر~\eqref{eq:latency_con} با توجه به مهلت مورد انتظار $\Theta_k$ برای درخواست $k$ با دو عبارت بدست‌آمده از تاخیر پردازش محلی و تاخیر بارسپاری بدست می‌آید.
\begin{equation} \label{eq:latency_con}
    x_{k,e,0}\frac{L_k}{f^{loc}_k} + \sum_{s \in \mathbb{S}} x_{k,e,s} \left(D_{k,e,s} + \sum_{m \in \mathbb{M}}\frac{L_k z_{s,m}}{f^{con}_k} C_{k,\mathbb{A}_m}\right) \\ \leq \Theta_k \quad \forall k \in \mathbb{K}_e, e \in \mathbb{E}
\end{equation}

\subsubsection{تابع هدف}
همانطور که در زیربخش~\ref{subsubsec:off_decision} بحث شد، درخواست‌ها ممکن است به دلیل عدم امکان تخصیص منابع یا براورده کردن مهلت مورد انتظار، حذف شوند. حذف درخواست‌های ناممکن کمک می‌کند سایر درخواست‌ها بدون افت کیفیت خدمت اجرا شوند. با توجه به آنکه درخواست‌های موجود در این پژوهش دارای حساسیت به تاخیر هستند، افت کارایی و کیفیت خدمت پذیرفته نیست. بر این اساس، مدیر و هماهنگ‌کننده شبکه \lr{\tt{MEC}} برای نسل چهارم صنعت، تلاش می‌کند ضمن براورده کردن کیفیت خدمت برای هر درخواست، حداکثر تعداد درخواست‌ها را در شبکه پاسخگو باشد. بر این اساس تابع هدف مساله بهینه‌سازی، تصمیم‌گیری تخصیص‌ درخواست‌ها را حداکثر یا به عبارت دیگر تعداد حذف درخواست‌ها را حداقل می‌کند.
\begin{equation} \label{eq:goal_func}
    \max_{x,z} \sum_{\substack{k \in \mathbb{K}_e, e \in \mathbb{E}\\ s \in \mathbb{S}}} x_{k,e,s}
\end{equation}

\subsection{خطی‌سازی قیود مساله بهینه‌سازی}
همانطور که در زیربخش~\ref{subsubsec:latency} بحث شد، عبارات غیرخطی به وجود آمده در تاخیر بارسپاری برای حل مساله بهینه‌سازی، نیازمند خطی‌سازی هستند. یکی از این عبارات غیرخطی در اثر فرمول تداخل و دیگری در اثر پهنای باند مشترک در فرمول تاخیر مخابره ایجاد شده است.
\subsubsection{خطی‌سازی تاخیر محاسبه بارسپاری شده}
برای خطی‌سازی تاخیر ناشی از مزاحمت دو متغیر کمکی $t_{k,s}$ و $u_{k,s}$ معرفی شده است. $t_{k,s}$ نشان‌دهنده تاخیر پردازش به همراه تداخل با ترکیب‌های مختلف بر سرور بارسپاری شده است. این متغیر خطی است و جهت ساده‌سازی نمایش در رابطه~\eqref{eq:lin_t_intro} معرفی شده است.
\begin{equation} \label{eq:lin_t_intro}
    t_{k,s} = \sum_{m \in \mathbb{M}}\frac{L_k z_{s,m}}{f^{con}_k} C_{k,\mathbb{A}_m}
\end{equation}
اما $u_{k,s}$ مطابق رابطه~\eqref{eq:lin_u_intro} نماینده یک عبارت غیرخطی است و در قید تاخیر جایگزین ضرب بین متغیر $x_{k,e,s}$ و مجموع $z_{s,m}$ها می‌شود.
\begin{equation} \label{eq:lin_u_intro}
    u_{k,s} = x_{k,e,s} t_{k,s}
\end{equation}
سپس قیود~\eqref{eq:lin_u_limit}، \eqref{eq:lin_UXH} و \eqref{eq:lin_UTXH} به منظور خطی‌سازی بخش پردازش بارسپاری همراه با تداخل در مساله بهینه‌سازی اضافه می‌شود. به این منظور بیشینه تاخیر بارسپاری ممکن برای درخواست $k$ در عبارت $H^{max}_k = \max_m \frac{L_k C_{k,\mathbb{A}_m}}{f^{con}_k}$ معرفی می‌شود. بیشترین حالت تداخل ممکن بر اساس نمایه برنامه فرض شده و یک حد بالا دستی $H^{max}_k$ برای استفاده در قیود خطی‌سازی انتخاب می‌شود.
\begin{equation} \label{eq:lin_u_limit}
    0 \leq u_{k,s} \leq t_{k,s}
\end{equation}
\begin{equation} \label{eq:lin_UXH}
    u_{k,s} \leq x_{k,e,s} H^{max}_k
\end{equation}
\begin{equation} \label{eq:lin_UTXH}
    u_{k,s} \geq t_{k,s} - (1-x_{k,e,s}) H^{max}_k
\end{equation}

\subsubsection{خطی‌سازی تاخیر مخابره}
برای تاخیر مخابره، اشتراک استفاده از پهنای باند سیمی و بی‌سیم، موجب ایجاد عبارت غیرخطی شده است. پهنای باند بین همه درخواست‌های متصل به نقطه دسترسی به طور مساوی تقسیم شده است. متغیر $q_s$ برای ساده‌سازی نمایش مجموع درخواست‌های پذیرفته شده برای بارسپاری در سرور $s$ در رابطه~\eqref{eq:lin_q_intro} استفاده می‌شود. متغیر $y_{k,e,s}$ نیز جایگزین عبارت غیرخطی ناشی از ضرب تصمیم‌گیری بارسپاری درخواست $k$ و اشتراک پهنای باند با همه درخواست‌های پذیرفته شده توسط سرور $s$، در رابطه~\eqref{eq:lin_y_intro} می‌شود.
\begin{equation} \label{eq:lin_q_intro}
    q_s = \sum_{k \in \mathbb{K}_e, e \in \mathbb{E}} x_{k,e,s}
\end{equation}
\begin{equation} \label{eq:lin_y_intro}
    y_{k,e,s} = x_{k,e,s} q_s
\end{equation}
قیود~\eqref{eq:lin_y_limit}، \eqref{eq:lin_YX} و \eqref{eq:lin_QYX} برای خطی‌سازی بخش مخابره به مساله بهینه‌سازی اضافه می‌شوند. حداکثر تعداد بارسپاری‌های یک سرور با $\mathcal{M}$ مشخص شده است.
\begin{equation} \label{eq:lin_y_limit}
    0 \leq y_{k,e,s} \leq q_s
\end{equation}
\begin{equation} \label{eq:lin_YX}
    y_{k,e,s} \leq \mathcal{M} x_{k,e,s}
\end{equation}
\begin{equation} \label{eq:lin_QYX}
    y_{k,e,s} \geq q_s - \mathcal{M} (1-x_{k,e,s})
\end{equation}
در نهایت با خطی‌سازی و ساده‌سازی‌های صورت گرفته، تاخیر پاسخگویی به درخواست $k$ طبق قید~\eqref{eq:latency_after_lin} محدود می‌شود.
\begin{equation} \label{eq:latency_after_lin}
    x_{k,e,0}\frac{L_k}{f^{loc}_k} + \sum_{s \in \mathbb{S}} \left(y_{k,e,s} + u_{k,s}\right) \leq \Theta_k \quad \forall k \in \mathbb{K}_e, e \in \mathbb{E}
\end{equation}

\section{شبیه‌سازی}

\subsection{انتخاب مجموعه نرم‌افزارهای معیار}

\subsection{فرایند اندازه‌گیری مزاحمت}

\subsection{معیارهای برآورد عملکرد}

\subsection{طرح‌های رقیب}

\section{نتایج}
